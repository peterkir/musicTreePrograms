/*
 * WARNING
 *
 * This file is maintained automatically by Bndtools.
 * You should not edit it.
 *
 * See the BUILDING-GRADLE.md document in the root project for more details.
 *
 * Bundle repository indexing tasks.
 */


/*
 * Syntax:
 * ext.indexDirectories = \
 *   '<root directory>;<name>;<name of fileTree property>, ...'
 *
 *  root directory           : mandatory.
 *  name                     : optional. if not specified then the basename of
 *                             the root directory is used.
 *  name of fileTree variable: optional. if not specified then all *.jar files
 *                             below the root directory will be indexed
 */
if (!hasProperty('indexDirectories'    )) ext.indexDirectories     = ''

if (!hasProperty('indexOBRUncompressed')) ext.indexOBRUncompressed = false
if (!hasProperty('indexOBRCompressed'  )) ext.indexOBRCompressed   = false
if (!hasProperty('indexR5Uncompressed' )) ext.indexR5Uncompressed  = false
if (!hasProperty('indexR5Compressed'   )) ext.indexR5Compressed    = true


ext.indexBindexJar     = "${rootDir}/${bndCnf}/gradle/dependencies/org.osgi.impl.bundle.bindex.jar"
ext.indexBindexMain    = 'org.osgi.impl.bundle.bindex.cli.Index'
ext.indexRepoindexJar  = "${rootDir}/${bndCnf}/gradle/dependencies/org.osgi.impl.bundle.repoindex.cli.jar"
ext.indexRepoindexMain = 'org.osgi.impl.bundle.bindex.cli.Index'


/*
 * Retrieve a property and ensure that it's an instance of FileTree
 */
FileTree getFileTreeInstance(String propertyName) {
  def fileTreeInstance = properties.get(propertyName)
  if (fileTreeInstance == null) {
    throw new GradleException("Property ${propertyName} not found")
  }
  if (!(fileTreeInstance instanceof FileTree)) {
    throw new GradleException("Property ${propertyName} is not an instance of FileTree")
  }

  return fileTreeInstance
}


/*
 * Create repository indexes
 *
 * Syntax:
 * ext.indexDirectories = \
 *   '<root directory>;<name>;<name of fileTree property>, ...'
 *
 *  root directory           : mandatory.
 *  name                     : optional. if not specified then the basename of
 *                             the root directory is used.
 *  name of fileTree variable: optional. if not specified then all *.jar files
 *                             below the root directory will be indexed
 */
void createIndexes(boolean r5, boolean uncompressed, boolean compressed) {
  assert(hasProperty('indexDirectories'))

  def indexerClasspath
  def indexerMain
  if (!r5) {
    assert(rootProject.hasProperty('indexBindexJar'))
    assert(rootProject.hasProperty('indexBindexMain'))

    indexerClasspath    = rootProject.files(rootProject.indexBindexJar )
    indexerMain         =                   rootProject.indexBindexMain
  } else {
    assert(rootProject.hasProperty('indexRepoindexJar'))
    assert(rootProject.hasProperty('indexRepoindexMain'))

    indexerClasspath    = rootProject.files(rootProject.indexRepoindexJar )
    indexerMain         =                   rootProject.indexRepoindexMain
  }

  indexDirectories.trim().split('\\s*,\\s*').each { indexDirectory ->
    def parts              = indexDirectory.trim().split('\\s*;\\s*')

    if (parts.length > 3) {
        throw new GradleException("Too many parts to the indexing configuration (${indexDirectories})")
    }

    if (parts.length > 1) {
        indexDirectory     = parts[0]
    }
    def indexDirectoryFile = file(indexDirectory)

    def repoName
    if (parts.length > 1) {
      repoName             = parts[1]
    } else {
      repoName             = indexDirectoryFile.name
    }

    if ((!indexDirectoryFile.exists() && !indexDirectoryFile.mkdirs()) || !indexDirectoryFile.isDirectory()) {
      throw new GradleException("Could not create directory ${indexDirectory}")
    }

    def bundlesToIndex
    if (parts.length > 2) {
      bundlesToIndex = getFileTreeInstance(parts[2])
    } else {
      bundlesToIndex = fileTree(indexDirectoryFile).include("**/*.jar")
    }

    def uncompressedIndexFile
    def compressedIndexFile
    if (!r5) {
      uncompressedIndexFile = file("${indexDirectory}/repository.xml")
      compressedIndexFile   = file("${indexDirectory}/repository.zip")
    } else {
      uncompressedIndexFile = file("${indexDirectory}/index.xml")
      compressedIndexFile   = file("${indexDirectory}/index.xml.gz")
    }

    if (uncompressedIndexFile.exists()) {
      uncompressedIndexFile.delete()
    }
    if (compressedIndexFile.exists()) {
      compressedIndexFile.delete()
    }

    def indexes = [[false, uncompressed], [true, compressed]]
    indexes.each { indexesEntry ->
      def compress      = indexesEntry[0]
      def generateIndex = indexesEntry[1]
      if (generateIndex) {
        def indexFile
        if (!compress) {
          indexFile        = uncompressedIndexFile
        } else {
          indexFile        = compressedIndexFile
        }

        def indexArgs      = []
        if (!r5) {
          indexArgs       += '-r'
          indexArgs       += indexFile
          indexArgs       += '-d'
          indexArgs       += indexDirectoryFile.toURI()
          indexArgs       += '-n'
          indexArgs       += repoName
        } else {
          if (!compress) {
            indexArgs     += '--pretty'
          }
          indexArgs       += '-r'
          indexArgs       += indexFile
          indexArgs       += '-d'
          indexArgs       += indexDirectoryFile
          indexArgs       += '-n'
          indexArgs       += repoName
        }

        if (!bundlesToIndex.isEmpty()) {
          bundlesToIndex.each {
            indexArgs     += relativePath(it)
          }
        }

        def result = javaexec {
          classpath      = indexerClasspath
          main           = indexerMain
          args           = indexArgs
        }
        if (result.exitValue != 0) {
          String msg = String.format("Could not create %s %s index in directory ${indexDirectory}",
            compress ? 'a compressed' : 'an uncompressed',
            r5 ? 'R5' : 'OBR')
          throw new GradleException(msg)
        }
      }
    }
  }
}


task index {
  description 'Generate OBR and R5 repository indexes (set the indexDirectories property)'
  group 'release'
  enabled !indexDirectories.isEmpty() &&
            (   indexOBRUncompressed
             || indexOBRCompressed
             || indexR5Uncompressed
             || indexR5Compressed)

  doLast {
    if (indexOBRUncompressed || indexOBRCompressed) {
      createIndexes(false, indexOBRUncompressed, indexOBRCompressed)
    }
    if (indexR5Uncompressed  || indexR5Compressed ) {
      createIndexes(true , indexR5Uncompressed , indexR5Compressed )
    }
  }
}
